\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{lipsum}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{rotating}
\usepackage[titletoc]{appendix}
\usepackage[left=2.5cm,top=3cm,right=2.5cm,bottom=3cm,bindingoffset=0.5cm]{geometry}
\title{\Huge \textbf{CPU Control} \\ \normalsize \it{Memory Interface and CPU Control \\ Fetch + Decode + Control + Datapath integration}} 
\author{Phillip Bradbury, Zach Toolson, Dan Willoughby}

\begin{document}
\maketitle
\clearpage

\tableofcontents
\clearpage

\section{Overview}
The combination of different modules makes the CPU able to decode assembly instructions, store data in memory, and perform operations. The decoder and controller deal with the parsing of instructions and setting the correct control signals. Dual port memory allows for the memory to be read and written to at the same time. The program counter and instruction FSM work together so that the CPU can execute the various instructions loaded into memory. The layout of the CPU can be seen in Figure \ref{fig:schematic}. The red lines show the control signals, while the black show the flow of the data. Each component, described in detail below, plays an important part in the overall operation of the CPU. 
\begin{center}
\begin{figure}
\caption{Schematic of CPU}
\makebox[\textwidth]{\includegraphics[width=\paperwidth]{cpu.png}}
\label{fig:schematic}
\end{figure} 
\end{center}
\section{Memory}
\subsection{Design}
We designed our memory to meet the needs of our duck hunt game. We wanted two separate 16384x18-bit dual-port RAM blocks to allow us to have 4 ports for reading and writing. The reason why we chose to have two RAM blocks, instead of one RAM block(32 blocks of 1024 was the max of the nexys 3 block ram), was so that we could have audio in one RAM block, and game information in the other.
 
We designed our memory to be a synchronous dual-port block RAM. The dual-port memory was so that our program counter could continually read the assembly instructions of the program from one port, while still reading and writing real-time data for the duck hunt game. We established the convention that the top portion of a memory block was the assembly instructions, while the remaining was left for the game data.

\subsection{Implementation}
Our implementation first had a flawed design, but then we reworked it to get one that met our needs. Our initial implementation included 30 separate blocks of memory. Each block was 1024 registers and we wanted to tie 30 blocks together, leaving two blocks for audio.  The idea behind having 30 blocks and 2 blocks, was so that we could have two ports for the 30 blocks and two ports for the remaining 2 blocks. The initial implementation had issues with the \$readmemh command. Because of the instantiation issue we decided to redesign the memory from scratch.
 
The next implementation of our memory followed closely to the example code given in lab. The code includes two read/write ports, each having its own data in and data out bus. It also had a separate clock for each port. We decided when we instantiated the memory module, to pass in the same clock as an argument. Using the same clock for both memories had no negative effect on the function of the memory. The memory module used two parameters for the data and the address. The parameters were set to a default value in the module. When instantiating the module to use the programmer can then change the variable values if desired. We set two parameters to the values of data = 18, and addr = 14. These numbers are based on the Block-RAM design of the Spartan 6 board, which gave us 32 blocks of RAM, with each block having 18k bits. Xilinx tools requires a special syntax to declare the memory, which we followed using the reg [DATA-1:0] mem [(2**ADDR)-1:0] command. We then use the \$readmemh command to read in a file and instantiate the memory with our game code at compile time. To implement our read/write memory design in Verilog we check if the memory should be writing or reading. When the positive edge of the clock hits, check to see if the memory is set to write. If it is, read the data out first before writing the incoming data, otherwise just read the data out of the address requested. This is a read-first memory design. With this second design, out memory worked properly and met the needs of our game design.


\subsection{Troubleshooting}
Initially, we had one 32 block RAM memory to use, but we wanted to have additional read/write ports. We started off by instantiating 30 blocks, but it didn’t synthesize to one block RAM. It instead was synthesized to distributed RAM. Our next thought to overcome the distributed RAM problem was to instantiate 30 blocks separately and tie them together with logic (huge case statement to direct each memory address to the correct block). We realized when we implemented the memory with our CPU that we could not instantiate memory with the assembly code. The reason we were getting distributed RAM when we had 30 blocks, was because the Xilinx tools require certain syntax when instantiating memory. Among these syntax rules, was that memory parameters such as data and address.  We also figured out with the help of the TA that the memory needed to be instantiated with a power of two address (reg [DATA-1:0] mem [(2**ADDR)-1:0];). We decided to have two 16 block memories giving us the extra ports that we wanted.

\section{Instruction FSM}
\subsection{Design}
The instruction FSM design was meant to give a life cycle for each assembly instruction. Depending on which instruction was read from memory, it took a longer or shorter amount of time to execute it. For example, a stor/load instruction can take up to 4 clock cycles while a non memory instruction takes only 3 clock cycles. We needed an FSM to account for these differences so that each instruction can work. We designed our FSM to be a moore finite state machine so the output only depended on the current state. The instruction FSM interacted with the PC counter with control signals.
The FSM has three main functions. One function that the FSM did was set the PC counter to an address which was read from a register(branches and jump). Another function was to increment the PC counter(for the next assembly instruction). The last main function was to interact with the ALU flags. Each state in the FSM corresponds to its function described in \ref{table:state}. The next state logic of the FSM ensured that each instruction was allowed enough time to execute fully.

\begin{table}
\centering
\caption{Description of instruction FSM states}
\begin{tabular}{|c|p{4in}|}
\hline
State & Description \\
\hline
fetch & Initial state, sets up the address for Instruction Memory \\
decode & After getting the data-out from the Instruction Memory \\
alu & After decode state, then goes straight to fetch \\
stor1 & State after decode which waits several cycles \\
stor2 & When output recieved, sets up the instructions to push to the register \\
load1 & State after decode which waits several cycles \\
load2 &  When output of memory is recievied signals the data was loaded \\
jump & Sets up the program counter with the new address \\
\hline
\end{tabular}
\label{table:state}
\end{table}

\subsection{Implementation}
The instruction FSM was implemented using a moore finite state machine design. We had present state logic, next state logic, and output logic each with its own associated always block statements. The present state logic had a sensitivity list to execute on the positive edge of the clock. If it was set to clear, then the present state would be set to fetch and the flags would be reloaded. Otherwise, the present state would be set to the next state. We also included some logic to fetch the flags from the ALU which made it so it took two cycles for the flags to actually change. We verified through testing that the flags were being set properly and it had no negative effect with our state machine. 

The next state logic always block determined the next state based off the the present state. For example, if the present state was fetch, the next state would be set to decode. Likewise, if the present state was decode, the next state would be determined by the decoded instruction. In this case, if it was a load instruction it would set to the load1 state(see \ref{table:state}). The rest of the next state states were determined in a similar fashion, always with the end result of the next state being set to the fetch state. 

The output logic block set the control signals to the ALU and the PC counter. For certain instructions such as branch, the FSM checked the flags set by the ALU. If it was a BEQ instruction, the FSM would determine if the zero flag was high and set the appropriate control signals. We also included some logic for compare operations, so that the flags had ample time to be set.
 
\subsection{Troubleshooting}
\label{fsm:trouble}
While implementing the instruction FSM, we encountered several issues. Originally we had a design that did not include an instruction FSM. The instruction was decoded and executed in the same clock cycle. Our design worked for simple instructions such as and, sub, and, xor etc. But it failed for the load and store instructions. We thought we could have our assembler create duplicate load/store instructions to compensate the for time delay of the memory. We found, however, that we could not stop the program counter from incrementing to the next instruction. This was a problem, because when a load/store instruction was encountered, it would execute the next assembly instruction multiple times. This was resolved by creating the instruction FSM which allowed for instructions to have a state.

Another main issue we encountered was that was that we did not have enough states for our instructions. This was a problem because the compare operation required a different amount of time than a simple ALU instruction. As a result, the problem encountered was that the branch instructions were not working correctly. For example, a BEQ would always branch instead of only branching when they are equal (zero flag =1 ). We resolved the problem by creating additional states for the compare instructions. The additional states allowed for the flags to be set and read correctly for the branch or jump instructions. 

Another main issue we encountered was with the load and store instructions not reading or loading the correct register. The incorrect register caused the output of the ALU to be undetermined (XXX). The undetermined output was an issue because we could not communicate with the reg file the appropriate value or address to be extracted from memory. We discovered that our datapath from memory that connected to the ALU-out datapath needed to have additional logic (needed a mux). The additional logic ensured that we were setting the memory data-out to the ALU-out datapath at the correct time. After we overcame these issues, the instruction FSM functioned properly.

\section{Decoder}

\subsection{Design}
The purpose of our decoder was to abstract away the decoding of the assembly instructions and send control signals to other components of the CPU. We had it separate from the instruction FSM so that it was easier to debug. Each instruction was parsed by 4 bit chunks. It would read the opcode,  opcode extension, the register destination / source / address, and immediate value. We had the decoder deal with reading 2’s complement immediate values. For example, if the instruction was addi we would extend the most significant bit sign to fill up the remaining 16 bits. 

After the assembly instruction was parsed, it would set the control signals corresponding to the instruction’s opcode. The decoder was responsible for communicating with the reg file, the memory, and muxes that control the flow of the datapath. 

\subsection{Implementation}
The implementation of the decoder required using a case statement to set each control signal. The register control signals needed to communicate to the reg file when to write and which register to read or write to or from, respectively. The first case statement was on the top 4 bits of the instruction (15:12). These 4 bits determine if the instruction was a register type instruction (add \$1, \$2), or any other instruction (immediate, shift, compare, branch, etc). We then had another case statement of the opcode extension bits (7:4) and it would set the opcode to communicate to the ALU which registers to read and load to the reg file.

The immediate instructions were similar to the register type instruction, except it would load in an immediate value. We had a case for each instruction that dealt with immediate values. The decoder would read in the immediate value from the instruction, extend the MSB if it was 2’s complement, and enabled the mux that allowed for an external immediate value to be loaded into the ALU. The immediate value would come from the decoder and be sent to the B port of the ALU. The compare and move immediate instructions were done in a similar fashion. The shift instructions required no extra logic to decode and worked similar to the register type instruction that they correlated with.

The last case was when we had a memory or branch type instruction. We decided to have the branch, jump, load, and store instructions have the same opcode. The reason was because we did not think that we would have very many branch instructions. The way the decoder differentiated between the branch instructions and the actual memory instructions (load / store) was by the opcode extension. The load instruction was responsible for enabling a control signal that switched the ALU-out bus to the B data-out port of the memory. This allowed for the value stored in memory to be loaded directly into the datapath. The store instruction was responsible for setting the write enable signal to the memory module. Both the load and store instructions set the B port address to be read/loaded. The decoder’s job with the branch and load instruction was to tell the reg file which registers to read and load to. The 4 LSB (3:0) specified which type of condition the branch was (equal, not equal, jump). The instruction FSM dealt with reading the flags of the ALU and which address to jump to. With the case statement on each instruction, it allowed us to easily implement the decoder.


\subsection{Troubleshooting}
We encountered several issues while implementing the decoder. One of the main issues was that we had a typo in one of our case statements. The typo was that it was a case statement from 17:6 instead of 17:16. As a result, there was bizarre behavior that confused us for several hours. Luckily, we were able to resolve the issue. 

Another issue we encountered with the decoder was that we weren’t setting the control signals to the correct values. When a control signal was the wrong value, it would either read the wrong register or not branch at the appropriate time. Since we had several signals on the output of our CPU, we were able to quickly determine which signal was incorrect. Overall, the decoder was just a large case statement, so the issues were resolved quickly.

\section{Program Counter}
\subsection{Design}
The goal for our program counter was simplicity. We moved some of the complicated things into our assembly code design and dealt with the problems there. This includes signed 2’s complement addresses and signed offsets. The program counter was designed so that we could set it to any address. We also allowed for the PC counter to be incremented by any value. The conventions we established were that addresses used to set the program counter must be an unsigned number. By setting some conventions, we greatly simplified our program counter.

\subsection{Implementation}
The program counter would increase each clock cycle by the increment value provided. The instruction FSM communicated to the PC counter how much to increment by. The main purpose behind having the increment being externally controlled was so that the instruction FSM could tell the PC counter when to increment. For example, when we did not want the program counter to increment, we would set the increment value to zero. When we did want it to increment, we would set the value to one. The external increment value also allowed us to have a jump instruction which would set the increment value to however far we wanted the program counter to jump. The increment value could be positive or negative. We used an always block with the posedge of the clock in the sensitivity list. The program counter would increment the output address by the increment value given unless an address was being set. In this case, the output address would become the input address. The instruction FSM was responsible for all of the life cycle of instructions. Therefore, we could have a relatively simple program counter.

\subsection{Troubleshooting}
We experienced one main issue with the program counter. With our initial FSM described  we could not prevent the program counter from incrementing before an instruction was executed (see \ref{fsm:trouble}). We attempted to have a program counter decrement to remain on the previous instruction, but this just complicated things more. Our solution was to add an instruction FSM that externally controlled the incrementation for assembly instructions. 

\section{CPU Datapath}
\subsection{Design}
The CPU datapath’s purpose was to instantiate all the modules, and to connect them all together. We instantiated each module, and then created wires to connect the inputs and outputs of the modules to each other. For example, we needed to connect the memory to the instruction FSM, decoder, and ALU. We abstracted the decoder and instruction FSM into its own module called the controller. The controller instantiated the required muxes / wires to communicate effectively between the decoder and instruction FSM.  The program counter needed to be connected to the controller and the memory. Because we abstracted most of the details away into separate modules, the CPU datapath was relatively straightforward. 

\subsection{Implementation}
The implementation of our CPU was instantiating modules and connecting them together. We instantiated the program counter, memory, and controller and then tied their inputs and outputs to their designated places. For documentation purposes, we declared each wire that connected the modules. We also had several outputs of different signals to aide us with debugging. The final addition to out CPU was a clock divider to allow enough time for instructions to be executed on the board. With all the modules connected, the CPU was able to execute a simple program.


\subsection{Troubleshooting}
Since the CPU datapath was relatively simple in design, we did not have any significant issues. We did however need to double check which wires we tied into each module. Refer to appendix \ref{test:demo} for the assembly program used to test all phases required for the lab. 


\section{ Waveforms of test operation }
\subsection{Phase i}
Loads data from memory into RegFile. Refer to Figure. \ref{fig:p1}. 

\subsection{Phase ii}
Performs a series of arithmetic and logical operations. Refer to Figure. \ref{fig:p2}. 

\subsection{Phase iii and Phase iv}
Stores the result into memory and reloads the result from memory into the RegFile.  Refer to Figure. \ref{fig:p3}. 

\subsection{Phase v and Phase vi}
Performs arithmetic to set flags and uses flags to perform branches. We implemented a loop that calls a method that displays the numbers 1 to 5, each iteration. Refer to Figure. \ref{fig:p4}. 

\subsection{Phase vii}
Writes the result into memory and displays the result. Refer to Figure. \ref{fig:p5}. 

\begin{center}
\begin{sidewaysfigure}
\caption{Load data from memory into RegFile}
\makebox[\textwidth]{\includegraphics[width=\paperwidth]{waveforms/load_store.png}}
\label{fig:p1}
\end{sidewaysfigure} 
\end{center}

\begin{center}
\begin{sidewaysfigure}
\caption{Performs a series of arithmetic and logical operations}
\makebox[\textwidth]{\includegraphics[width=\paperwidth]{waveforms/arithmetic.png}}
\label{fig:p2}
\end{sidewaysfigure} 
\end{center}

\begin{center}
\begin{sidewaysfigure}
\caption{Stores the result into memory and reloads the result from memory into the RegFile. }
\makebox[\textwidth]{\includegraphics[width=\paperwidth]{waveforms/load_store2.png}}
\label{fig:p3}
\end{sidewaysfigure} 
\end{center}

\begin{center}
\begin{sidewaysfigure}
\caption{Performs arithmetic to set flags and uses flags to perform branches.}
\makebox[\textwidth]{\includegraphics[width=\paperwidth]{waveforms/loop_setflags.png}}
\label{fig:p4}
\end{sidewaysfigure} 
\end{center}

\begin{center}
\begin{sidewaysfigure}
\caption{Perform a series of arithmetic and logical operations}
\makebox[\textwidth]{\includegraphics[width=\paperwidth]{waveforms/branch_show.png}}
\label{fig:p5}
\end{sidewaysfigure} 
\end{center}

\section{Conclusion}
The results of Lab 3 and Lab 4 were that we were able to run our own assembly programs on our CPU. We found several errors as we were testing, which we were able to correct. It would have been near impossible to test the CPU without the different components seperated into different modules. The combination of all the modules formed a complex design, which could perform interesting operations. The CPU successfully running a program we wrote was very exciting and encouraging. 


\newpage
\appendixname
\appendix
\section{Synthesis Results}
\subsection{Memory}
\begin{lstlisting}
Synthesizing Unit <memory>.
    DATA = 18
    ADDR = 14
    Found 16384x18-bit dual-port RAM <Mram_mem> for signal <mem>.
    Found 18-bit register for signal <b_dout>.
    Found 18-bit register for signal <a_dout>.
    Summary:
inferred   1 RAM(s).
inferred  36 D-type flip-flop(s).
inferred   1 Multiplexer(s).
\end{lstlisting}
\subsection{Instruction FSM}
\begin{lstlisting}
Synthesizing Unit <instruction FSM>.
    Found 5-bit register for signal <FLAGS>.
    Found 3-bit register for signal <PS>.
    Found finite state machine <FSM 0> for signal <PS>.
    --------------------------------------------
    | States             | 8                   |
    | Transitions        | 13                  |
    | Inputs             | 4                   |
    | Outputs            | 7                   |
    | Clock              | CLK (rising edge)   |
    | Reset              | CLR (positive)      |
    | Reset type         | synchronous         |
    | Reset State        | 000                 |
    | Encoding           | auto                |
    | Implementation     | LUT                 |
    --------------------------------------------
    Summary:
    inferred   5 D-type flip-flop(s).
    inferred   7 Multiplexer(s).
    inferred   1 Finite State Machine(s).
\end{lstlisting}
\subsection{Decoder}
\begin{lstlisting}
Synthesizing Unit <decoder>.
    Found 8-bit 15-to-1 multiplexer for signal <inst[15]_PWR_9_o_wide_mux_37_OUT> created at line 102.
    Found 4-bit 4-to-1 multiplexer for signal <_n0144> created at line 304.
    Summary:
    inferred  50 Multiplexer(s).
Unit <decoder> synthesized.
\end{lstlisting}
\subsection{Program Counter}
\begin{lstlisting}
Synthesizing Unit <program_counter>.
    Found 14-bit register for signal <out_addr>.
    Found 14-bit adder for signal <out_addr[13]_GND_2_o_add_1_OUT> created at line 37.
    Summary:
    inferred   1 Adder/Subtractor(s).
    inferred  14 D-type flip-flop(s).
    inferred   1 Multiplexer(s).
\end{lstlisting}
\section{Memory}
\subsection{Module}
\tiny \verbatiminput{../memory.v}
\subsection{FSM}
\tiny \verbatiminput{../memory_FSM.v}
\subsection{Memory Load test}
\tiny \verbatiminput{../memory2_test_file_readin.v}
\subsection{Memory test}
\tiny \verbatiminput{../memory_test.v}
\section{Controller (Decoder and FSM)}
\subsection{Instruction FSM Module}
\tiny \verbatiminput{../instruction_FSM.v}
\subsection{Controller Module}
\tiny \verbatiminput{../controller_integrated.v}
\subsection{Decoder Module}
\tiny \verbatiminput{../decoder.v}
\subsection{Controller Test}
\tiny \verbatiminput{../controller_integrated_test.v}
\subsection{Instruction FSM Test}
\tiny \verbatiminput{../instruction_FSM_test.v}
\subsection{Decoder Test}
\tiny \verbatiminput{../decoder_tb.v}
\section{Program Counter}
\subsection{Module}
\tiny \verbatiminput{../program_counter.v}
\subsection{Test}
\tiny \verbatiminput{../program_counter_test.v}
\section{CPU}
\subsection{Module}
\tiny \verbatiminput{../CPU.v}
\subsection{Test}
\tiny \verbatiminput{../CPU_test.v}
\section{Assembly Test Code}
\subsection{Load and Store}
\tiny \verbatiminput{../assembler/cpu_sto_test.asm}
\subsection{Demo Code}
\label{test:demo}
\tiny \verbatiminput{../assembler/demo.asm}

\end{document}
